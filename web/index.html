<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link type="text/css" href="styles.css" rel="stylesheet" />
    <link
    href="https://sp-bootstrap.global.ssl.fastly.net/7.4.1/sp-bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.datatables.net/1.10.12/css/dataTables.bootstrap.min.css" rel="stylesheet" media="screen">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="shortcut icon" href="images/favicon.png">
    <title>Organize Your Music</title>
    <!-- Custom styles for this template -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
  <body >
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            <span class="navbar-logo">Spotify</span>
            <span class="navbar-title">Organize Your Music</span>
          </a>
        </div>
      </div>
    </div>

    <!-- Main jumbotron for a primary marketing message or call to action -->
      <div id='intro'>
      <div id='main' class="top jumbotron jumbotron-hero container-fluid">
          <div  class="container" id="jumbo-dialog">
            <h1 id='ttitle' >Organize Your Music</h1>
            <p id='ttext'>
                Organize your Spotify music
                by any of a wide range of musical attributes including
                genre, mood, decade of release and more.
            </p>

            <div class='col-md-offset-3 col-md-6 form-group'>
                <label id="what-label" for="collection-type"> What do you want to organize: </label>
                <select id="collection-type" class="form-control">
                    <option value='saved'> Songs you've saved to Your Music</option>
                    <option value='added'> Songs you've added to a playlist</option>
                    <option value='follow'> Songs in playlists you follow </option>
                    <option value='all'> All of your music</option>
                </select>
                <br>
                <a class="btn btn-primary btn-lg go" id='go' role="button">Organize your music</a>
                <p> </p>
            </div>
            <div class='err-txt'> </div>
          </div>
      </div>

        <div class="container ">
          <div class="row features">
             <div class="col-md-offset-2 col-md-8">
                    <h2 class="text-center">Get your music collection in order</h2>
                    <p>
                    With <b> Organize Your Music </b> you can easily organize
                    your saved music. Just follow these steps:
                    </p>
                    <ol>
                        <li> <b> Select  </b> what music you'd
                        like to organize: Your Saved Music; Music you've added
                        to playlists; Music in playlists you follow; or all of
                        it.
                        <li> <b> Click </b> on <i>Organize your Music</i>.
                        If this is your first visit, you will be asked to ...
                        <li>  <b> Login </b> with your Spotify
                        credentials. <b> Organize Your Music</b> will place all
                        of your tracks into a number of bins. There are Genres,
                        Moods, Decades, Popularity and more, bins with more 
                        being added all the time.
                        <li>  <b> Pick </b> pick one of the bins. You can listen
                        to previews of the songs in the bin. If you like it you
                        can ...
                        <li>  <b> Save </b> the bin to Spotify as a playlist
                    </ol>
                    <p> Don't worry. <b> Organize Your Music </b> will never modify any of
                    the songs in your saved music or playlists. It will only save
                    new playlists for you, and only when you explictly click on
                    the <b> save </b> button.

                    </p>
              </div>
          </div>
        </div>
        </div>

  <div class="row ">
  <div id="sidebar" class="sidebar work"> </div>

  <div id="main-wrapper">
      <div class="work" id="main-area">
        <h3 id="section-title" class="ntext-center"></h3>
          <div id="loading">
            <div id="loading-header">
                <h4 id="lplaylist-name" class="ntext-center"></h4>
                <div id="linfo"> </div>
                <div id='tiny-track'> </div>
                <div class="progress">
                   <div id="progress-bar" class="progress-bar" role="progressbar"
                        aria-valuenow="00" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
                      <span class="sr-only">00% Complete</span> </div>
                </div>
            </div>
            <button id='stop-loading' class='btn btn-xs btn-default'> Stop </button>
             <div class='loading-text'>
                We are loading up all of your music. This may take a while
                depending upon how big your music collection is.  If you are
                impatient, you can stop the loading at anytime to work with a
                subset of your music.
                </p>
            </div>
            <div id="favs" class='loading-text'>
                Looks like you really enjoy your <span class="fav-text" id='fav-genre'> </span>
                and <span class="fav-text" id="fav-artist"> </span>.  It seems like one of your
                favorite songs is <span class="fav-text" id="fav-song"></span>.
            </div>
          </div>
          <div id="loaded">
            <div id="info"> </div>
            <div id="exTab3" class="ccontainer">    
                <ul  class="nav nav-tabs">
                    <li class="active"> <a  href="#the-track-list" 
                            data-toggle="tab">The Track list</a> </li>
                    <li><a href="#the-plots" data-toggle="tab">The Plots</a> </li>
                </ul>

                <div class="tab-content clearfix">
                  <div class="tab-pane active" id="the-track-list">
                    <h4 id="playlist-title" class="ntext-center"></h4>
                      <div>
                          <br>
                          <button id="save-button" class="btn btn-xs pull-right btn-primary">
                          Save as playlist </button>
                      </div>
                      <table id="the-track-table" class="table table-responsive">
                        <col width="5%">
                        <col width="5%">
                        <col width="5%">
                        <col width="35%">
                        <col width="35%">
                        <col width="15%">
                        <thead>
                            <tr>
                                <th> # </th>
                                <th> Count </th>
                                <th> Pop </th>
                                <th> artist </th>
                                <th> title </th>
                                <th id='tbl-param'>  </th>
                            </tr>
                        </thead>
                        <tbody id='track-table'> </tbody>
                      </table>
                      <div id='table-disclaimer'>
                        Showing only the first 400 tracks in this bin 
                      </div>
                   </div>
                    <div class="tab-pane" id="the-plots">
                        <br>
                        <p>
                            Sweet, sweet plots, charts and graphs coming soon.
                        </p>
                        <div id="the-plot" style="width:800px;height:550px;"></div>
                    </div>
                </div>
            </div>

              <br>
          </div>
      </div>
    </div>

    <div style="clear:both"> </div>
    <div id="footer">
      <div class="container text-center">
            <p class="text-muted">
                Powered by <a href="http://spotify.com">Spotify</a>.
                Created by <a href="http://twitter.com/plamere">@plamere</a>
                at <a href="http://labrosa.ee.columbia.edu/hamr_ismir2016/">The
                Science of Music Hackathon in NYC on Aug 6, 2016</a>.
                Get the <a
                href="https://github.com/plamere/OrganizeYourMusic">source</a>.
            </p>
      </div>
    </div>
    <script src="lib/jquery-1.11.1.min.js"></script>
    <script src="lib/moment.min.js"></script>
    <script src="https://sp-bootstrap.global.ssl.fastly.net/7.4.1/sp-bootstrap.min.js"></script>
    <script src="lib/underscore-min.js"></script>
    <script src="https://cdn.datatables.net/1.10.12/js/jquery.dataTables.min.js"></script>
    <script type="text/javascript" charset="utf-8"
        src="lib/rsvp-latest.min.js"></script>
   <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <script src="config.js"></script>

<script>
"use strict";
var accessToken = null;
var curUserID = null;
var curTracks = {};
var curArtists = {};
var curAlbums = {};
var nodeMap = { }
var genreIndex = 0;
var sourceIndex = 6;

var skipGenrePhrases = ['christmas'];
var audio = $("<audio>");
var nowPlaying = null;
var curNode = null;
var abortLoading = false;

var progressBar = $("#progress-bar");

var topArtistCount = 0;
var totalTracks = 0;
var topArtistName = null;
var topTrackName = null;
var topTrackCount = 0;
var totalPlaylists = 0;
var processedPlaylists = 0;

RSVP.on('error', function(reason) {
  console.assert(false, reason);
});


var theWorld = [
    {
        name: "Genres",
        nodes: [ ],
    },
    {
        name: "Moods",
        nodes: [
            makeNode("(unclassified mood)", "popularity", featMissingFilter('energy'),
                                        featGetterInt('popularity'),
                                        featSorter('popularity', true)),
            makeNode("chill", "energy", featMusicFilter('energy', 0, .2),
                                        featGetterPercent('energy'),
                                        featSorter('energy', false)),
            makeNode("amped", "energy", featMusicFilter('energy', .8, 1.0),
                                        featGetterPercent('energy'),
                                        featSorter('energy', true)),
            makeNode("sad", "sadness", featMusicFilter('sadness', .8, 1.0),
                                        featGetterPercent('sadness'),
                                        featSorter('sadness', true)),
            makeNode("anger", "anger", featMusicFilter('anger', .8, 1.0),
                                        featGetterPercent('anger'),
                                        featSorter('anger', true)),
            makeNode("happy", "happiness", featMusicFilter('happiness', .8, 1.0),
                                        featGetterPercent('happiness'),
                                        featSorter('happiness', true)),
            makeNode("danceable", "danceability", featMusicFilter('danceability', .8, 1.0),
                                        featGetterPercent('danceability'),
                                        featSorter('danceability', true)),
        ]
    },
    {
        name: "Styles",
        nodes: [
            makeNode("instrumental", "instrumentalness",
                featMusicFilter('instrumentalness', .8, 1.0),
                featGetterPercent('instrumentalness'),
                featSorter('instrumentalness', true)),
            makeNode("acoustic", "acousticness",
                featMusicFilter('acousticness', .8, 1.0),
                featGetterPercent('acousticness'),
                featSorter('acousticness', true)),
            makeNode("live", "liveness",
                featMusicFilter('liveness', .85, 1.0),
                featGetterPercent('liveness'),
                featSorter('liveness', true)),
            makeNode("spoken word", "speechiness",
                featFilter('speechiness', .85, 1.0),
                featGetterPercent('speechiness'),
                featSorter('speechiness', true)),
            makeNode("clean", "explicit",
                featBoolFilter('explicit', false),
                featGetterBool('explicit', 'explicit', 'clean'),
                featSorter('explicit', true)),

            makeNode("explicit", "explicit",
                featBoolFilter('explicit', true),
                featGetterBool('explicit', 'explicit', 'clean'),
                featSorter('explicit', true)),
            makeNode("loud", "loudness (dB)",
                featMusicFilter('loudness', -5, 0),
                featGetterInt('loudness'),
                featSorter('loudness', true)),
            makeNode("quiet", "loudness (dB)",
                featMusicFilter('loudness', -60, -10),
                featGetterInt('loudness'),
                featSorter('loudness', false)),
        ]
    },
    {
        name: "Decades",
        nodes: [
            makeNode("Oldies", "year",
                featFilter('year', 0, 1950),
                featGetter('year'),
                featSorter('year', false)),
            makeNode("1950s", "year",
                featFilter('year', 1950, 1959),
                featGetter('year'),
                featSorter('year', false)),
            makeNode("1960s", "year",
                featFilter('year', 1960, 1969),
                featGetter('year'),
                featSorter('year', false)),
            makeNode("1970s", "year",
                featFilter('year', 1970, 1979),
                featGetter('year'),
                featSorter('year', false)),
            makeNode("1980s", "year",
                featFilter('year', 1980, 1989),
                featGetter('year'),
                featSorter('year', false)),
            makeNode("1990s", "year",
                featFilter('year', 1990, 1999),
                featGetter('year'),
                featSorter('year', false)),
            makeNode("2000s", "year",
                featFilter('year', 2000, 2009),
                featGetter('year'),
                featSorter('year', false)),
            makeNode("2010s", "year",
                featFilter('year', 2010, 2019),
                featGetter('year'),
                featSorter('year', false)),
            makeNode("Now", "year",
                featFilter('year', 2016, 2020),
                featGetter('year'),
                featSorter('year', false)),
            makeNode("(unclassified year)", "year",
                featFilter('year', -1, 0),
                featGetter('year'),
                featSorter('year', false)),
        ]
    },
    {
        name: "Added",
        nodes: [
            makeNode("Today", "age (days)",
                featFilter('age', 0, 1),
                featGetterInt('age'),
                featSorter('age', false)),
            makeNode("In the last week", "age (days)",
                featFilter('age', 0, 7),
                featGetterInt('age'),
                featSorter('age', false)),
            makeNode("In the last month", "age (days)",
                featFilter('age', 0, 30),
                featGetterInt('age'),
                featSorter('age', false)),
            makeNode("In the last year", "age (days)",
                featFilter('age', 0, 365),
                featGetterInt('age'),
                featSorter('age', false)),
            makeNode("Over a year ago", "age (days)",
                featFilter('age', 356, 365 * 100),
                featGetterInt('age'),
                featSorter('age', false)),
            makeNode("Over 2 years ago", "age (days)",
                featFilter('age', 356 * 2, 365 * 100),
                featGetterInt('age'),
                featSorter('age', false)),
            makeNode("Over 5 years ago", "age (days)",
                featFilter('age', 356 * 5, 365 * 100),
                featGetterInt('age'),
                featSorter('age', false)),
            makeNode("Whenever", "age (days)",
                featFilter('age', 0, 365 * 100),
                featGetterInt('age'),
                featSorter('age', false)),
        ]
    },
    {
        name: "Popularity",
        nodes: [
            makeNode("popular", "Popularity",
                featFilter('popularity', 60, 100),
                featGetter('popularity'),
                featSorter('popularity', true)),
            makeNode("mainstream", "Popularity",
                featFilter('popularity', 40, 60),
                featGetter('popularity'),
                featSorter('popularity', true)),
            makeNode("hipster", "Popularity",
                featFilter('popularity', 10, 40),
                featGetter('popularity'),
                featSorter('popularity', true)),
            makeNode("deep", "Popularity",
                featFilter('popularity', 0, 10),
                featGetter('popularity'),
                featSorter('popularity', true)),
        ]
    },
    {
        name: "Sources",
        nodes: [ ],
    },
];


function now() {
    return new Date().getTime();
}

function updateFavs() {
    if (theWorld[genreIndex].nodes.length > 0 && topArtistName && topTrackName) {
        var favGenre = theWorld[genreIndex].nodes[0].name
        $("#fav-genre").text(favGenre);
        $("#fav-artist").text(topArtistName);
        $("#fav-song").text(topTrackName);
        $("#favs").show();
    }
}

function refreshHeader() {
    var ntracks = Object.keys(curTracks).length;
    var nArtists = Object.keys(curArtists).length;
    if (totalPlaylists > 0) {
        linfo("Found " + ntracks + " unique tracks  by " + nArtists
        + " artists in " + processedPlaylists + " of "
        + totalPlaylists + " playlists");
        var progress =  processedPlaylists * 100 / totalPlaylists;
        setProgress(progress);
    } else {
        if (totalTracks > 0) {
            var progress =  ntracks * 100 / totalTracks;
            setProgress(progress);
        }
        linfo("Found " + ntracks + " tracks  by "
        + nArtists + " artists in your collection.");
    }
}

function addTracks(tracks) {
    _.each(tracks, function(track) {
        var genres = getGenresForTrack(track);
        track.feats.genres = new Set();
        _.each(genres, function(genre) {
            if (isGoodGenre(genre)) {
                track.feats.genres.add(genre);
                if (!(genre in nodeMap) ) {
                    var node = makeNode(genre, "Genre",
                            featGenreFilter(genre),
                            featGenreGetter(genre),
                            featSorter('popularity', true));
                    theWorld[genreIndex].nodes.push(node);
                }
                if (!(track.feats.source in nodeMap)) {
                    var node = makeNode(track.feats.source, "Source",
                            featSourceFilter(track.feats.source),
                            featSourceGetter(track.feats.source),
                            featSorter('popularity', true));
                    theWorld[sourceIndex].nodes.push(node);
                }
            }
        });

        track.feats.year = getYearForTrack(track);
    });

    _.each(theWorld, function(bin) {
        _.each(bin.nodes, function(node) {
            _.each(applyFilter(tracks, node.filter), function(track) {
                node.tracks.push(track);
                node.artists.add(track.details.artists[0].id);
            });
        });
    });
}

var totRefresh = 0;

function refreshTheWorld(quick) {
    var start = now();
    if (!quick) {
        //collapseGenres();
    }
    updateViewOfTheWorld(quick);
    var delta = now() - start;
    totRefresh += delta;
    //console.log('refresh:', delta, totRefresh);
}

// needs some more thought
function collapseGenres() { 
    var nodes = theWorld[genreIndex].nodes;
    var used = new Set();
    sortedNodes(nodes);
    var keep = [];

    _.each(theWorld[genreIndex].nodes, function(node) {
        var count = 0;
        _.each(node.tracks, function(track) {
            if (!used.has(track.id)) {
                used.add(track.id);
                count += 1;
            }
        });
        if (count > 0) {
            keep.push(node);
            console.log('keeping ', node.name);
        } else {
            console.log('dropping ', node.name);
        }
    });
    console.log('keeping', keep.length, 'orginal was', nodes.length);
    theWorld.push( 
        {
            name:"Collapsed Genres",
            nodes:keep
        }
    );
}


function playlistSubtitle(s) {
    $("#playlist-sub-title").text(s);
}

function playlistTitle(s) {
    $("#playlist-title").text(s);
}

function plotPlaylist(node) {
    drawTestPlot();
}

function showPlaylist(node) {
    plotPlaylist(node);
    var maxVisibleTracks = 400;
    curNode = node;
    var nTracks = node.tracks.length;
    var nArtists = node.artists.size;
    playlistTitle("Your " + uname(node.name) + " tracks" );
    playlistSubtitle(nTracks + " tracks / " + nArtists + " artists");

    if (node.tracks.length > maxVisibleTracks) {
        $("#table-disclaimer").show();
    } else {
        $("#table-disclaimer").hide();
    }

    var tbl = $("#track-table");
    tbl.empty();
    $("#tbl-param").text(node.label);
    _.each(node.tracks, function(track, i) {
        if (i > maxVisibleTracks) {
            return ;
        }
        var tr = $("<tr>");
        tr.addClass("playable");
        tr.append($("<td>").text(i + 1));
        tr.append($("<td>").text(track.feats.count));
        tr.append($("<td>").text(track.feats.popularity));
        tr.append($("<td>").text(track.details.name));
        tr.append($("<td>").text(track.details.artists[0].name));
        tr.append($("<td>").text(node.getter(track)));
        tr.on("click", function() {
            tr.addClass("playing");
            playTrack(track);
        });
        tbl.append(tr);
    });
    //$("#the-track-table").DataTable();
}

function saveTracksToPlaylist(playlist, inputTracks) {
    var tracks = inputTracks.slice();
    function saveTracks() {
        var uris = [];

        while (tracks.length > 0 && uris.length < 100) {
            var track = tracks.shift();
            uris.push(track.details.uri);
        }

        var url = "https://api.spotify.com/v1/users/" + curUserID
            + "/playlists/" + playlist.id + "/tracks";
        var params = {
            uris:uris
        }
        callSpotify("POST", url, params, function(ok, results) {
            if (ok) {
                if (tracks.length > 0) {
                    saveTracks();
                } else {
                    info("playlist saved");
                }
            } else {
                error("Trouble adding tracks to playlist");
            }
        });
    }
    saveTracks();
}

function makeNode(name, label, filter, getter, sorter) {
    var node = {
        name:name,
        label:label,
        tracks:[],
        artists: new Set(),
        filter:filter,
        getter:getter,
        sorter:sorter
    };
    if (name in nodeMap) {
        console.log("WARNING, dup node", name);
    }
    nodeMap[name] = node;
    return node;
}

function savePlaylist() {
    if (curNode != null) {
        info("saving " + uname(curNode.name));
        var url = "https://api.spotify.com/v1/users/" + curUserID + "/playlists"
        callSpotify("POST", url, {name:"Your " + uname(curNode.name) + " tracks" }, function(ok, results) {
            if (ok) {
                saveTracksToPlaylist(results, curNode.tracks);
            } else {
                error("Trouble creating playlist");
            }
        })
    }
}

function updateViewOfTheWorld(quick) {
    var minTracksForSection = 0;
    var sidebar = $("#sidebar");
    sidebar.empty();
    var first = true;

    updateFavs();
    _.each(theWorld, function(bin) {
        var nodes = sortedNodes(bin.nodes);
        var head = $("<h4>").text(uname(bin.name));
        head.attr("data-toggle", "collapse");
        head.attr("data-target", "#" + nname(bin.name));
        sidebar.append(head);
        var ul = $("<ul class='playlist-list collapse in'>");
        ul.attr("id", nname(bin.name));
        sidebar.append(ul);
        _.each(nodes, function(node) {
            var tracks = node.tracks;
            if (tracks.length >= minTracksForSection) {
                var header = $("<li>").text(uname(node.name));
                var nArtists = node.artists.size;
                var stats = $("<span class='stats'>").text("(" + tracks.length +
                    " tracks / " + nArtists + " artists)");
                header.append(stats);
                if (!quick) {
                    header.on("click", function() {
                        showPlaylist(node);
                    });
                    if (first) {
                        first = false;
                        showPlaylist(node);
                    }
                } else {
                }
                ul.append(header);
            }
        });
    });
}

function nname(s) {
    return s.replace(/ /g, '_');
}

function uname(s) {
    return s.replace(/_/g, ' ');
}

function sortedNodes(nodes) {
    nodes.sort(function(a,b) {
        if (a.name == '(unclassified genre)') {
            return 1;
        } else if (b.name == '(unclassified genre)') {
            return -1;
        } else {
            if (a.tracks.length > b.tracks.length) {
                return -1;
            } else if (a.tracks.length < b.tracks.length) {
                return 1;
            } else {
                return 0;
            }
        }
    });
    return nodes;
}

function featGenreFilter(genre) {
    return function(track) {
        return track.feats.genres.has(genre);
    };
}


function featGenreGetter(genre) {
    return function(track) {
        var glist = Array.from(track.feats.genres);
        return glist.join(', ');
    };
}

function featGenreSorter(genre) {
    return function(tracks) {
        tracks.sort(function(a,b) {
            if (a.feats.genres.size > b.feats.genres.size) {
                return 1;
            } else if (a.feats.genres.size < b.feats.genres.size) {
                return -1;
            } else {
                return b.feats.popularity - a.feats.popularity;
            }
        });
        return tracks;
    };
}

function featSourceFilter(source) {
    return function(track) {
        return track.feats.source == source;
    };
}

function featSourceGetter(source) {
    return function(track) {
        return track.feats.source;
    };
}

function featSorter(param, reverse) {
    return function(tracks) {
        tracks.sort(function(a,b) {
            if (a.feats[param] > b.feats[param]) {
                return 1;
            } else if (a.feats[param] < b.feats[param]) {
                return -1;
            } else {
                return 0;
            }
        });
        if (reverse) {
            tracks.reverse();
        }
        return tracks;
    };
}

function featGetter(param) {
    return function(track) {
        return track.feats[param];
    };
}

function featGetterInt(param) {
    return function(track) {
        return Math.round(track.feats[param]);
    };
}

function featGetterPercent(param) {
    return function(track) {
        return Math.round(100 * track.feats[param]);
    };
}

function featGetterBool(param, true_val, false_val) {
    return function(track) {
        return track.feats[param] ? true_val : false_val;
    };
}

function featBoolFilter(param, state) {
    return function(track) {
        return 'feats' in track &&
                track.feats[param] == state;
    };
}
function featMusicFilter(param, low, high) {
    return function(track) {
        return 'feats' in track &&
                track.feats.speechiness < .8 &&
                track.feats[param] >= low &&
                track.feats[param] <= high;
    };
}

function featMissingFilter(param) {
    return function(track) {
        return (! ('energy' in track.feats));
    };
}

function featFilter(param, low, high) {
    return function(track) {
        return 'feats' in track &&
                track.feats[param] >= low &&
                track.feats[param] <= high;
    };
}

function applyFilter(tracks, filt) {
    var out = [];
    _.each(tracks, function(track) {
        if (filt(track)) {
            out.push(track);
        }
    });
    return out;
}


function getYearForTrack(track) {
    var year = -1;
    if (track.details.album_id in curAlbums) {
        var album = curAlbums[track.details.album_id];
        if ('release_date' in album) {
            var date = album.release_date;
            if (date.length >=4) {
                var syear = date.substring(0,4);
                year = parseInt(syear);
            }
        }
    }
    return year;
}

function getGenresForTrack(track) {
    var genres = [];
    var albumId = track.details.album_id;
    if (albumId in curAlbums) {
        var album = curAlbums[albumId];
        _.each(album.genres, function(g) {
            genres.push(g);
        });
    }

    _.each(track.details.artists, function(artist) {
        if (artist.id in curArtists) {
            var detailedArtist = curArtists[artist.id];
            _.each(detailedArtist.genres, function(genre) {
                genres.push(genre);
            });
        }
    });
    if (genres.length == 0) {
        genres.push('(unclassified genre)');
    }
    return genres;
}

function isGoodGenre(genre) {
    var lgenre = genre.toLowerCase();
    for (var i = 0; i < skipGenrePhrases.length; i++) {
        var phrase = skipGenrePhrases[i];
        if (lgenre.indexOf(phrase) != -1) {
            return false;
        }
    }
    return true;
}

function error(msg) {
    info(msg);
}

function info(msg) {
    $("#info").text(msg);
}

function linfo(msg) {
    $("#linfo").text(msg);
}

function authorizeUser() {
    var scopes = 'user-library-read playlist-modify-public';
    var url = 'https://accounts.spotify.com/authorize?client_id=' + SPOTIFY_CLIENT_ID +
        '&response_type=token' +
        '&show_dialog=false' +
        '&scope=' + encodeURIComponent(scopes) +
        '&redirect_uri=' + encodeURIComponent(SPOTIFY_REDIRECT_URI);
    document.location = url;
}

function parseArgs() {
    var hash = location.hash.replace(/#/g, '');
    var all = hash.split('&');
    var args = {};
    _.each(all, function(keyvalue) {
        var kv = keyvalue.split('=');
        var key = kv[0];
        var val = kv[1];
        args[key] = val;
    });
    return args;
}

function callSpotify(type, url, json, callback) {
    $.ajax(url, {
        type: type,
        data: JSON.stringify(json),
        dataType: 'json',
        headers: {
            'Authorization': 'Bearer ' + accessToken,
            'Content-Type': 'application/json'
        },
        success: function(r) {
            callback(true, r);
        },
        error: function(r) {
            // 2XX status codes are good, but some have no
            // response data which triggers the error handler
            // convert it to goodness.
            if (r.status >= 200 && r.status < 300) {
                callback(true, r);
            } else {
                callback(false, r);
            }
        }
    });
}


function getSpotifyP(url, data) {
    return new RSVP.Promise(function(resolve, reject) {
        var curRetry = 0;
        var maxRetries = 10;
        function go() {
          $.ajax(url, {
              dataType: 'json',
              data: data,
              headers: {
                  'Authorization': 'Bearer ' + accessToken
              },
              beforeSend : function () {
                  // console.log("GET: " + this.url);
              },
              success: function(data) {
                  resolve(data);
              },
              error: function(jqXHR, textStatus) {
                  if (jqXHR.status >= 200 && jqXHR.status < 300) {
                      resolve(jqXHR);
                  } else if (jqXHR.status == 401) {
                      window.location = 'index.html';
                  } else if (jqXHR.status >= 500 && jqXHR.status < 600) {
                    if (curRetry++ < maxRetries) {
                        console.log('500 retry', curRetry, jqXHR.status);
                        setTimeout(go, 500);
                    } else {
                        console.log('500 error', jqXHR);
                        reject(textStatus + " after " + maxRetries + " retries");
                    }
                  } else if (jqXHR.status == 429) {
                      console.log("429 status", jqXHR);
                      var retry = 2000;
                      var retryAfter = jqXHR.getResponseHeader("Retry-After");
                      console.log("retryAfter is", retryAfter);

                      if (retryAfter) {
                          retry = parseInt(retryAfter, 10) * 1000;
                      }
                      if (retry < 1000) {
                          retry = 1000;
                      }
                      console.log("retry", retry);
                      if (curRetry++ < maxRetries) {
                          console.log('429 retry', curRetry);
                          setTimeout(go, retry + curRetry * retry);
                      } else {
                          console.log('429 error', jqXHR);
                          reject(textStatus + " after " + maxRetries + " retries");
                      }
                    } else {
                      reject(textStatus);
                  }
              }
          });
      }
      go();
    });
}


function fetchCurrentUserProfile() {
    var url = 'https://api.spotify.com/v1/me';
    return getSpotifyP(url, null);
}


function playTrack(track) {
    if (track != nowPlaying) {
        audio.attr('src', track.details.preview_url);
        audio.get(0).play();
        nowPlaying = track;
    } else {
        stopTrack();
    }
}

function stopTrack() {
    audio.get(0).pause();
    nowPlaying = null;
    $(".playing").removeClass("playing");
}


function collectAudioAttributes(tracks) {
    var trackIds = [];
    _.each(tracks, function(track) {
        trackIds.push(track.id);
    });

    return getSpotifyP("https://api.spotify.com/v1/audio-features",
        { ids: trackIds.join(',')})
        .then(function(results) {
          _.each(results.audio_features, function(audio_feature) {
              if (audio_feature) {
                  var track = curTracks[audio_feature.id];
                  //track.audio_feature = audio_feature;
                  _.each(audio_feature, function(val, name) {
                      track.feats[name] = val;
                  });
                  track.feats.sadness=  (1 - audio_feature.energy) * (1 - audio_feature.valence);
                  track.feats.happiness = audio_feature.energy * audio_feature.valence;
                  track.feats.anger = audio_feature.energy * (1 - audio_feature.valence);
              }
          });
          return results;
    });
}

function collectArtistAttributes(tracks) {
    var aids = [];
    var maxArtistsPerCall = 50;
    var deferred = RSVP.defer();

    function getNextArtists() {
        var nextAids = getNextBatch(aids, maxArtistsPerCall);
        if (nextAids.length > 0) {
            return getSpotifyP("https://api.spotify.com/v1/artists", { ids: nextAids.join(',')})
              .then(function(results) {
                _.each(results.artists, function(artist) {
                    curArtists[artist.id] = {
                        genres:artist.genres,
                        name:artist.name,
                        count: 1
                    }
                });
                getNextArtists();
            })
            .catch(function(error) {
                deferred.reject(error);
            });
        }  else {
            deferred.resolve(curArtists);
        }
    }

    var aidsSet = new Set();
    _.each(tracks, function(track) {
        _.each(track.details.artists, function(artist) {
            if (! (artist.id in curArtists)) {
                aidsSet.add(artist.id);
            } else {
                curArtists[artist.id].count += 1;
                var count = curArtists[artist.id].count;
                if (count > topArtistCount) {
                    topArtistCount = count;
                    topArtistName = curArtists[artist.id].name;
                }
            }
        });
    });
    aids = Array.from(aidsSet);
    getNextArtists();
    return deferred.promise;
}


function collectAlbumAttributes(tracks) {
    var maxAlbumsPerCall = 20;
    var aids = [];
    var deferred = RSVP.defer();

    function getNextAlbums() {
        var nextAids = getNextBatch(aids, maxAlbumsPerCall);
        if (nextAids.length > 0) {
            getSpotifyP("https://api.spotify.com/v1/albums", { ids: nextAids.join(',')})
            .then(function(results) {
                _.each(results.albums, function(album) {
                    curAlbums[album.id] = {
                        release_date:album.release_date,
                        genres:album.genres,
                    };
                });
                getNextAlbums();
            })
            .catch(function(error) {
              deferred.reject(error);
            });
        } else {
          deferred.resolve(curAlbums);
        }
    }

    var aidSet = new Set();
    _.each(tracks, function(track) {
        if (! (track.details.album_id in curAlbums)) {
            aidSet.add(track.details.album_id);
        }
    });
    aids = Array.from(aidSet);
    getNextAlbums();
    return deferred.promise;
}

function getNextBatch(list, nitems) {
    var out = [];
    while (list.length > 0 && out.length  < nitems) {
        out.push(list.shift());
    }
    return out;
}


var trackTextQueue = [];
var showingTracks = false;
var tt = $("#tiny-track");

function showTracks(prefix, tracks) {
    _.each(tracks, function(track) {
        var text = prefix + " - " + track.details.artists[0].name
                + " - " +  track.details.name;
        trackTextQueue.push(text);
    });
}

function showTracksUpdater() {
    if (showingTracks) {
        if (trackTextQueue.length > 0) {
            var text = trackTextQueue.shift();
            tt.text(text);
            //tt.text(trackTextQueue.length + " " + text);
        }
        if (trackTextQueue.length > 0) {
            setTimeout(showTracksUpdater, 40);
        } else {
            setTimeout(showTracksUpdater, 300);
        }
    } else {
        tt.text("");
    }
}

function startShowingTracks() {
    showingTracks = true;
    showTracksUpdater();
}

function stopShowingTracks() {
    showingTracks = false;
}

function getTracksFromAPI(source, uri) {
    var deferred = RSVP.defer();

    function go(offset) {
        var params = {
            limit:50,
            market:'from_token',
            offset:offset,
        }
        getSpotifyP(uri, params)
        .then(
          function(results) {
            var now = moment();
            var tracks = [];
            _.each(results.items, function(item) {
                if (!item.is_local && item.track && ('id' in item.track)) {
                    item.track.added_at = item.added_at;
                    item.track.date_added = moment(item.added_at);
                    item.track.age = moment.duration(now.diff(item.track.date_added)).asDays();
                    var track = {
                        id:item.track.id,
                        feats: {
                            date_added:moment(item.added_at),
                            age:moment.duration(now.diff(item.track.date_added)).asDays(),
                            explicit:item.track.explicit,
                            duration_ms:item.track.duration_ms,
                            popularity:item.track.popularity,
                            source:source,
                            count:1,
                        },
                        details: {
                            name:item.track.name,
                            album_id:item.track.album.id,
                            uri:item.track.uri,
                            preview_url:item.track.preview_url,
                            artists:tinyArtists(item.track.artists),
                        }
                    }
                    if (track.id in curTracks) {
                        curTracks[track.id].feats.count += 1;
                        var count = curTracks[track.id].feats.count;
                        if (count > topTrackCount) {
                            topTrackCount = count;
                            topTrackName = item.track.name;
                        }
                    } else {
                        tracks.push(track);
                        curTracks[track.id] = track;
                    }
                }
            });
            showTracks(source, tracks);
            refreshHeader();
            totalTracks = results.total;

            collectAudioAttributes(tracks)
            .then( function() {
                return collectArtistAttributes(tracks);
            })
            .then( function() {
                return collectAlbumAttributes(tracks);
            })
            .then(function() {
              addTracks(tracks);
              if (!abortLoading && results.offset + results.items.length < results.total) {
                go(results.offset + results.items.length);
              } else {
                refreshTheWorld(true);
                deferred.resolve(curTracks);
              }
            });
          })
          .catch(function(error) {
            deferred.reject(error);
          });
      }
    go(0);
    return deferred.promise;
}

function tinyArtists(artists) {
    var tartists = [];
    _.each(artists, function(artist) {
        var tartist = {
            id:artist.id,
            name:artist.name,
        }
        tartists.push(tartist);
    });
    return tartists;
}

function getSavedTracks() {
    startShowingTracks();
    $("#lplaylist-name").text("Your Saved Tracks");
    getTracksFromAPI("Your Saved tracks", "https://api.spotify.com/v1/me/tracks")
    .then(function(results) {
    })
    .catch(function(results){
      console.log("GST catch " + results);
    })
    .finally(function() {
        stopShowingTracks();
        refreshTheWorld(false);
        $("#loaded").show();
        $("#loading").hide();
    });
}

function getAllMusic() {
    startShowingTracks();
    $("#lplaylist-name").text("Your Saved Tracks");
    getTracksFromAPI("Your Saved Tracks", "https://api.spotify.com/v1/me/tracks")
    .then(function(results) {
        getMusicFromPlaylists(true);
    });
}

function getMusicFromPlaylists(allPlaylists) {
    // get all the tracks from all the 'own'
    // playlists of the user, up to a maximum amount
    var deferred = RSVP.defer();

    function getMyPlaylists(offset) {
        var params = { limit:50, offset:offset };
        getSpotifyP("https://api.spotify.com/v1/me/playlists", params)
        .then(function(results) {
            if (results) {
                var outstandingPlaylists = [];
                var count = results.offset + results.items.length;
                totalPlaylists = results.total;
                _.each(results.items, function(playlist) {
                    outstandingPlaylists.push(playlist);
                });
                loadPlaylists(outstandingPlaylists, allPlaylists)
                .then(function() {
                    if (!abortLoading && count < results.total) {
                        getMyPlaylists(count);
                    } else {
                      deferred.resolve(outstandingPlaylists);
                    }
                });
            } else {
                deferred.reject(new Error("can't get your playlist"));
            }
        })
        .catch(function(error) {
          deferred.reject(error);
        });
    }

    startShowingTracks();
    getMyPlaylists(0);

    deferred.promise.then( function() {
    })
    .catch(function(theError) {
        error("trouble, " + theError);
    })
    .finally(function() {
        stopShowingTracks();
        refreshTheWorld(false);
        $("#loaded").show();
        $("#loading").hide();
    });
}

var quickMode = false;

function loadPlaylists(playlists, allPlaylists) {
    var deferred = RSVP.defer();

    function fetchNextPlaylist() {
        if (!abortLoading && playlists.length > 0) {
            processedPlaylists += 1;
            var playlist = playlists.shift();
            if (quickMode && processedPlaylists > 100) {
                return deferred.resolve(playlists);
            }
            if (isGoodPlaylist(playlist, allPlaylists)) {
                $("#lplaylist-name").text(playlist.name + " (" + playlist.tracks.total + " tracks)");
                getPlaylistTracks(playlist)
                  .then(function() {
                    fetchNextPlaylist();
                  })
                  .catch(function(error) {
                    console.log("trouble loading playlist", playlist);
                    fetchNextPlaylist();
                    // return deferred.reject(error);
                  })
            } else {
                fetchNextPlaylist();
            }
        } else {
            return deferred.resolve(playlists);
        }
    }
    fetchNextPlaylist();
    return deferred.promise;
}

function isGoodPlaylist(playlist, allPlaylists) {
    if (allPlaylists || playlist.owner.id == curUserID) {
        if (playlist.tracks.total > 0) {
            return true;
        }
    }
    return false;
}

function getPlaylistTracks(playlist) {
    var uri = playlist.uri;
    if (isValidPlaylistUri(uri)) {
        var fields = uri.split(':');
        var userID = fields[2];
        var playlistID = fields[4];
        var url = "https://api.spotify.com/v1/users/"
            + userID + "/playlists/" + playlistID + "/tracks";
        return getTracksFromAPI(playlist.name, url);
    } else {
        var deferred = RSVP.defer();
        deferred.reject(new Error("bad playlist URI"));
        return deferred.promise;
    }
}

function isLocalHost() {
    return window.location.host.indexOf('localhost') >= 0;
}

function isValidPlaylistUri(uri) {
    var fields = uri.split(':');
    if (fields.length != 5) {
        return false;
    }
    if (fields[0] != 'spotify' || fields[3] != 'playlist') {
        return false;
    }
    return true;
}

function saveInfo(params) {
    localStorage.setItem("info", JSON.stringify(params));
}

function getInfo(params) {
    var item = localStorage.getItem("info");
    return JSON.parse(item);
}

function go() {
    $('.err-txt').text("");
    var type = $("#collection-type").val();
    var params = {
        "type": type,
    }
    saveInfo(params);
    authorizeUser();
}

function goAll() {
    $('.err-txt').text("");
    var params = {
        "type": "all",
    }
    saveInfo(params);
    authorizeUser();
}

function normalizeUri(uri) {
    uri = uri.replace("https://open.spotify.com", 'spotify');
    uri = uri.replace("https://play.spotify.com", 'spotify');
    uri = uri.replace(/\//g, ':');
    return uri;
}

function stopLoading() {
    console.log('stop loading');
    abortLoading = true;
    linfo("Stopping ... hang on ...");
}

function goPlaylist() {
    $('.err-txt').text("");
    var uri = normalizeUri($("#uri-text").val());
    if (isValidPlaylistUri(uri)) {
        var params = {
            "type": "playlist",
            "uri": uri
        }
        saveInfo(params);
        authorizeUser();
    } else {
        $('.err-txt').text("That's not a playlist URI");
    }
}

function setProgress(percent) {
  progressBar.css('width', percent+'%').attr('aria-valuenow', percent);
}

function drawTestPlot() {
    return;
    var TESTER = $("#the-plot").get(0);
    Plotly.plot( TESTER, [{
        x: [1, 2, 3, 4, 5],
        y: [1, 2, 4, 8, 16] }], {
        margin: { t: 0 } } );
}

$(document).ready(
    function() {
        if (isLocalHost()) {
            SPOTIFY_REDIRECT_URI = LOCAL_SPOTIFY_REDIRECT_URI;
        }
        var args = parseArgs();
        window.location.hash = "";
        $(".work").hide();
        if ('error' in args) {
            error("Sorry, I can't read your music collection from Spotify without authorization");
            $("#go").show();
            $("#go").on('click', function() {
                go();
            });
        } else if ('access_token' in args) {
            $(".work").show();
            $("#intro").hide();
            accessToken = args['access_token'];
            $("#stop-loading").on('click', function() {
                stopLoading();
            });
            $("#save-button").on("click", function() {
                savePlaylist();
            });
            fetchCurrentUserProfile()
            .then(function(user) {
                if (user) {
                    curUserID = user.id;
                    $("#who").text(user.id);
                    var info = getInfo();
                    var curType = info.type;
                    var curTypeName = $("#collection-type option[value='" + curType +"']").text()
                    $("#section-title").text(curTypeName);
                    if (info.type == "saved") {
                        getSavedTracks();
                    } else if (info.type == "added") {
                        getMusicFromPlaylists(false);
                    } else if (info.type == "follow") {
                        getMusicFromPlaylists(true);
                    }  else if (info.type == "all") {
                        getAllMusic();
                    } else {
                        console.log("unexpected type", info.type);
                    }
                } else {
                    error("Trouble getting the user profile");
                }
            });
        } else {
            $("#go").show();
            $("#go").on('click', function() {
                go();
            });
        }
    }
);

</script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3675615-27']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type =
'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>

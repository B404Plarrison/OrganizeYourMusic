<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link type="text/css" href="styles.css" rel="stylesheet" />
    <link href="dist/sp-bootstrap.min.css" rel="stylesheet" media="screen">
    <link href="https://cdn.datatables.net/1.10.12/css/dataTables.bootstrap.min.css" rel="stylesheet" media="screen">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="shortcut icon" href="images/favicon.png">
    <title>Organize Your Music</title>
    <!-- Custom styles for this template -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
  <body >
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            <span class="navbar-logo">Spotify</span>
            <span class="navbar-title">Organize Your Music</span>
          </a>
        </div>
      </div>
    </div>

    <!-- Main jumbotron for a primary marketing message or call to action -->
      <div id='intro'>
      <div id='main' class="top jumbotron jumbotron-hero container-fluid">
          <div  id="jumbo-dialog">
            <h1 id='ttitle' >Organize Your Music</h1>
            <p id='ttext'>
                Organize your Spotify collection 
                by any of a wide range of musical attributes including
                genre, mood, decade of release and more.
            </p>
            <p>
            <a class="btn btn-primary btn-lg go" id='go' role="button">Organize
            your saved music</a>
            <!--
            <a class="btn btn-primary btn-lg go" id='go-all' role="button">Organize
            all your music</a> -->
            </p>
            <p> </p>
            <p> Or enter a playlist URI to organize the music in a particular playlist </p>
            <div class="row">
                <div class="col-md-offset-3 col-md-6">
                    <div id="uri-prompt" class="input-group align-center">
                        <input id="uri-text" type="text" class='form-control' 
                            placeholder="spotify:user:spotify:playlist:5FJXhjdILmRA2z5bvz4nzf">
                        <span class="input-group-btn">
                            <button class="btn btn-primary type="button" 
                                id='uri-go' role="button">Go</button>
                        </span>
                    </div>
                </div>
            </div>
            <div class='err-txt'> </div>
          </div>
      </div>

        <div class="container ">
          <div class="row features">
             <div class="col-md-offset-2 col-md-8">
                    <h2 class="text-center">Get your music collection in order</h2>
                    <p>
                    With <b> Organize Your Music </b> you can easily organize 
                    yoru saved music. Just follow these steps:
                    </p>
                    <ol>
                        <li> <b> Click </b> on <i>Organize your Saved Music </i>
                        or enter a playlist URI.  You will be asked to ...
                        <li>  <b> Login </b> with your Spotify
                        credentials. <b> Organize Your Music</b> will place all
                        of your tracks into a number of bins. There are Genre
                        Moods, Decades and Popularity bins with more being added
                        all the time.
                        <li>  <b> Pick </b> pick one of the bins. You can listen
                        to previews of the songs in the bin. If you like it you
                        can ...
                        <li>  <b> Save </b> the bin to Spotify as a playlist 
                    </ol>
                    <p> Don't worry. <b> Organize Your Music </b> will never modify any of
                    the songs in your saved music or playlists. It will only save
                    new playlists for you, and only when you explictly click on
                    the <b> save </b> button.
                        
                    </p>
              </div> 
          </div>
        </div>
        </div>

  <div class="row ">
  <div id="sidebar" class="sidebar work"> </div>

  <div id="main-wrapper">
      <div class="work" id="main-area">
          <div id='info' class="text-center"></div>
          <div id='tiny-track'> </div>
          <div class="progress">
            <div id="progress-bar" class="progress-bar" role="progressbar" 
                aria-valuenow="00" aria-valuemin="0" aria-valuemax="100" style="width: 0%;">
            <span class="sr-only">00% Complete</span> </div>
          </div>
          <h3 id="playlist-title"> </h3> 
          <div id="playlist-sub-title"> </div>
          <div>
              <button id="save-button" class="btn btn-xs npull-right btn-primary"> 
              Save as playlist </button>
          </div>
          <br>
          <table id="the-track-table" class="table table-responsive">
            <col width="5%">
            <col width="5%">
            <col width="5%">
            <col width="35%">
            <col width="35%">
            <col width="15%">
            <thead>
                <tr>
                    <th> # </th>
                    <th> Count </th>
                    <th> Pop </th>
                    <th> artist </th>
                    <th> title </th>
                    <th id='tbl-param'>  </th>
                </tr>
            </thead>
            <tbody id='track-table'> </tbody>
          </table>
      </div>
    </div>

    <div style="clear:both"> </div>
    <div id="footer">
      <div class="container text-center">
            <p class="text-muted">
                Powered by <a href="http://spotify.com">Spotify</a>.
                Created by <a href="http://twitter.com/plamere">@plamere</a>
                at <a href="http://labrosa.ee.columbia.edu/hamr_ismir2016/">The
                Science of Music Hackathon in NYC on Aug 6, 2016</a>.
                Get the <a
                href="https://github.com/plamere/OrganizeYourMusic">source</a>.
            </p>
      </div>
    </div>
    <script src="lib/jquery-1.11.1.min.js"></script>
    <script src="lib/moment.min.js"></script>
    <script src="lib/bootstrap.min.js"></script>
    <script src="lib/underscore-min.js"></script>
    <script src="https://cdn.datatables.net/1.10.12/js/jquery.dataTables.min.js"></script>
    <script type="text/javascript" charset="utf-8"
        src="//cdnjs.cloudflare.com/ajax/libs/q.js/1.4.1/q.min.js"></script>
    <script src="config.js"></script>

<script>
"use strict";
var accessToken = null;
var curUserID = null;
var curTracks = {};
var curArtists = {};
var curAlbums = {};

var skipGenrePhrases = ['christmas'];
var audio = $("<audio>");
var nowPlaying = null;
var curNode = null;
var curType = 'collection';
var curName = 'Your';
var totalPlaylists = 0;
var processedPlaylists = 0;
var curPlaylistName = "";
var needsRefresh = false;
var progressBar = $("#progress-bar");
var totalTracks = 0;

var theWorld = [
    {
        name: "Genres",
        nodes: [ ],
    },
    {
        name: "Moods",
        nodes: [
            makeNode("(unclassified)", "popularity", featMissingFilter('energy'), 
                                        featGetterInt('popularity'), 
                                        featSorter('popularity', true)),
            makeNode("chill", "energy", featMusicFilter('energy', 0, .2), 
                                        featGetterPercent('energy'), 
                                        featSorter('energy', false)),
            makeNode("amped", "energy", featMusicFilter('energy', .8, 1.0), 
                                        featGetterPercent('energy'), 
                                        featSorter('energy', true)),
            makeNode("sad", "sadness", featMusicFilter('sadness', .8, 1.0), 
                                        featGetterPercent('sadness'), 
                                        featSorter('sadness', true)),
            makeNode("anger", "anger", featMusicFilter('anger', .8, 1.0), 
                                        featGetterPercent('anger'), 
                                        featSorter('anger', true)),
            makeNode("happy", "happiness", featMusicFilter('happiness', .8, 1.0), 
                                        featGetterPercent('happiness'), 
                                        featSorter('happiness', true)),
            makeNode("danceable", "danceability", featMusicFilter('danceability', .8, 1.0), 
                                        featGetterPercent('danceability'), 
                                        featSorter('danceability', true)),
        ]
    },
    {
        name: "Styles",
        nodes: [
            makeNode("instrumental", "instrumentalness",
                featMusicFilter('instrumentalness', .8, 1.0), 
                featGetterPercent('instrumentalness'), 
                featSorter('instrumentalness', true)),
            makeNode("acoustic", "acousticness",
                featMusicFilter('acousticness', .8, 1.0), 
                featGetterPercent('acousticness'), 
                featSorter('acousticness', true)),
            makeNode("live", "liveness",
                featMusicFilter('liveness', .85, 1.0), 
                featGetterPercent('liveness'), 
                featSorter('liveness', true)),
            makeNode("spoken word", "speechiness",
                featFilter('speechiness', .85, 1.0), 
                featGetterPercent('speechiness'), 
                featSorter('speechiness', true)),
            makeNode("clean", "explicit",
                featBoolFilter('explicit', false), 
                featGetterBool('explicit', 'explicit', 'clean'), 
                featSorter('explicit', true)),

            makeNode("explicit", "explicit",
                featBoolFilter('explicit', true), 
                featGetterBool('explicit', 'explicit', 'clean'), 
                featSorter('explicit', true)),
            makeNode("loud", "loudness (dB)",
                featMusicFilter('loudness', -5, 0), 
                featGetterInt('loudness'), 
                featSorter('loudness', true)),
            makeNode("quiet", "loudness (dB)",
                featMusicFilter('loudness', -60, -10), 
                featGetterInt('loudness'), 
                featSorter('loudness', false)),
        ]
    },
    {
        name: "Decades",
        nodes: [
            makeNode("Oldies", "year",
                featFilter('year', 0, 1950), 
                featGetter('year'), 
                featSorter('year', false)),
            makeNode("1950s", "year",
                featFilter('year', 1950, 1959), 
                featGetter('year'), 
                featSorter('year', false)),
            makeNode("1960s", "year",
                featFilter('year', 1960, 1969), 
                featGetter('year'), 
                featSorter('year', false)),
            makeNode("1970s", "year",
                featFilter('year', 1970, 1979), 
                featGetter('year'), 
                featSorter('year', false)),
            makeNode("1980s", "year",
                featFilter('year', 1980, 1989), 
                featGetter('year'), 
                featSorter('year', false)),
            makeNode("1990s", "year",
                featFilter('year', 1990, 1999), 
                featGetter('year'), 
                featSorter('year', false)),
            makeNode("2000s", "year",
                featFilter('year', 2000, 2009), 
                featGetter('year'), 
                featSorter('year', false)),
            makeNode("2010s", "year",
                featFilter('year', 2010, 2019), 
                featGetter('year'), 
                featSorter('year', false)),
            makeNode("Now", "year",
                featFilter('year', 2016, 2020), 
                featGetter('year'), 
                featSorter('year', false)),
            makeNode("(unclassified)", "year",
                featFilter('year', -1, 0), 
                featGetter('year'), 
                featSorter('year', false)),
        ]
    },
    {
        name: "Added",
        nodes: [
            makeNode("Today", "age (days)",
                featFilter('age', 0, 1), 
                featGetterInt('age'), 
                featSorter('age', false)),
            makeNode("In the last week", "age (days)",
                featFilter('age', 0, 7), 
                featGetterInt('age'), 
                featSorter('age', false)),
            makeNode("In the last month", "age (days)",
                featFilter('age', 0, 30), 
                featGetterInt('age'), 
                featSorter('age', false)),
            makeNode("In the last year", "age (days)",
                featFilter('age', 0, 365), 
                featGetterInt('age'), 
                featSorter('age', false)),
            makeNode("Over a year ago", "age (days)",
                featFilter('age', 356, 365 * 100), 
                featGetterInt('age'), 
                featSorter('age', false)),
            makeNode("Over 2 years ago", "age (days)",
                featFilter('age', 356 * 2, 365 * 100), 
                featGetterInt('age'), 
                featSorter('age', false)),
            makeNode("Over 5 years ago", "age (days)",
                featFilter('age', 356 * 5, 365 * 100), 
                featGetterInt('age'), 
                featSorter('age', false)),
            makeNode("Whenever", "age (days)",
                featFilter('age', 0, 365 * 100), 
                featGetterInt('age'), 
                featSorter('age', false)),
        ]
    },
    {
        name: "Popularity",
        nodes: [
            makeNode("popular", "Popularity",
                featFilter('popularity', 60, 100), 
                featGetter('popularity'), 
                featSorter('popularity', true)),
            makeNode("mainstream", "Popularity",
                featFilter('popularity', 40, 60), 
                featGetter('popularity'), 
                featSorter('popularity', true)),
            makeNode("hipster", "Popularity",
                featFilter('popularity', 10, 40), 
                featGetter('popularity'), 
                featSorter('popularity', true)),
            makeNode("deep", "Popularity",
                featFilter('popularity', 0, 10), 
                featGetter('popularity'), 
                featSorter('popularity', true)),
        ]
    }
];

function now() {
    return new Date().getTime();
}

function refreshHeader() {
    var ntracks = Object.keys(curTracks).length;
    var nArtists = numArtists(curTracks);
    if (curType == 'all') {
        info("Found " + ntracks + " unique tracks  by " + nArtists 
        + " artists in " + processedPlaylists + " of " 
        + totalPlaylists + " playlists");
        if (totalPlaylists > 0) {
            var progress =  processedPlaylists * 100 / totalPlaylists;
            setProgress(progress);
        }
    } else {
        if (totalTracks > 0) {
            var progress =  ntracks * 100 / totalTracks;
            setProgress(progress);
        }
        info("Found " + ntracks + " tracks  by " 
        + nArtists + " artists in your " + curType+ ".");
    }
}

function refreshTheWorld() {
    if (needsRefresh) {
        var start = now();
        refreshHeader();
        refreshGenres();
        refreshReleaseYear();
        _.each(theWorld, function(bin) {
            _.each(bin.nodes, function(node) {
               node.tracks = node.sorter(applyFilter(curTracks, node.filter));
            });
        });
        updateViewOfTheWorld();
        console.log('refresh too', now() - start, 'ms');
        needsRefresh = false;
    }
}

function subtitle(s) {
    $("#playlist-sub-title").text(s);
}

function showPlaylist(node) {
    var maxVisibleTracks = 400;
    curNode = node;
    var nTracks = node.tracks.length;
    var nArtists = numArtists(node.tracks);
    $("#playlist-title").text(curName + " " + uname(node.name) + " tracks" );
    subtitle(nTracks + " tracks / " + nArtists + " artists");

    var tbl = $("#track-table");
    tbl.empty();
    $("#tbl-param").text(node.label);
    _.each(node.tracks, function(track, i) {
        if (i > maxVisibleTracks) {
            return ;
        }
        var tr = $("<tr>");
        tr.addClass("playable");
        tr.append($("<td>").text(i + 1));
        tr.append($("<td>").text(track.feats.count));
        tr.append($("<td>").text(track.feats.popularity));
        tr.append($("<td>").text(track.details.name));
        tr.append($("<td>").text(track.details.artists[0].name));
        tr.append($("<td>").text(node.getter(track)));
        tr.on("click", function() {
            $(".playing").removeClass("playing");
            tr.addClass("playing");
            playTrack(track);
        });
        tbl.append(tr);
    });
    //$("#the-track-table").DataTable();
}

function saveTracksToPlaylist(playlist, tracks) {

    function saveTracks() {
        var uris = [];

        while (tracks.length > 0 && uris.length < 100) {
            var track = tracks.shift();
            uris.push(track.details.uri);
        }

        var url = "https://api.spotify.com/v1/users/" + curUserID 
            + "/playlists/" + playlist.id + "/tracks";
        var params = {
            uris:uris
        }
        callSpotify("POST", url, params, function(ok, results) {
            if (ok) {
                if (tracks.length > 0) {
                    saveTracks();
                } else {
                    info("playlist saved");
                }
            } else {
                error("Trouble adding tracks to playlist");
            }
        });
    }
    saveTracks();
}

function makeNode(name, label, filter, getter, sorter) {
    var node = {
        name:name,
        label:label,
        tracks:[],
        filter:filter,
        getter:getter,
        sorter:sorter
    };
    return node;
}

function savePlaylist() {
    if (curNode != null) {
        info("saving " + uname(curNode.name));
        var url = "https://api.spotify.com/v1/users/" + curUserID + "/playlists"
        callSpotify("POST", url, {name:"Your " + uname(curNode.name) + " tracks" }, function(ok, results) {
            if (ok) {
                saveTracksToPlaylist(results, curNode.tracks);
            } else {
                error("Trouble creating playlist");
            }
        })
    }
}

function updateViewOfTheWorld() {
    var minTracksForSection = 5;
    var sidebar = $("#sidebar");
    sidebar.empty();
    var first = true;

    _.each(theWorld, function(bin) {
        var nodes = sortedNodes(bin.nodes);
        var head = $("<h4>").text(uname(bin.name));
        head.attr("data-toggle", "collapse");
        head.attr("data-target", "#" + nname(bin.name));
        sidebar.append(head);
        var ul = $("<ul class='playlist-list collapse in'>");
        ul.attr("id", nname(bin.name));
        sidebar.append(ul);
        _.each(nodes, function(node) {
            var tracks = node.tracks;
            if (tracks.length >= minTracksForSection) {
                var nArtists = numArtists(node.tracks);
                var header = $("<li>").text(uname(node.name));
                var stats = $("<span class='stats'>").text("(" + tracks.length +
                " tracks / " + nArtists + " artists)");
                header.append(stats);
                ul.append(header);
                header.on("click", function() {
                    showPlaylist(node);
                });
                if (first) {
                    first = false;
                    showPlaylist(node);
                }
            }
        });
    });
}

function numArtists(tracks) {
    var sartists = new Set();

    _.each(tracks, function(track) {
        if (track.details.artists.length > 0) {
            sartists.add(track.details.artists[0].id);
        }
    });
    return sartists.size;
}

function nname(s) {
    return s.replace(/ /g, '_');
}

function uname(s) {
    return s.replace(/_/g, ' ');
}

function sortedNodes(nodes) {
    nodes.sort(function(a,b) {
        if (a.name == '(unclassified)') {
            return 1;
        } else if (b.name == '(unclassified)') {
            return -1;
        } else {
            if (a.tracks.length > b.tracks.length) {
                return -1;
            } else if (a.tracks.length < b.tracks.length) {
                return 1;
            } else {
                return 0;
            }
        }
    });
    return nodes;
}

function refreshGenres() {
    var allGenres = new Set();
    _.each(curTracks, function(track) {
        var genres = getGenresForTrack(track);
        track.feats.genres = new Set();
        _.each(genres, function(genre) {
            if (isGoodGenre(genre)) {
                allGenres.add(genre);
                track.feats.genres.add(genre);
            }
        });
    });
    var gnodes = [];
    theWorld[0].nodes = gnodes;
    _.each(Array.from(allGenres), function(genre) {
        var node = makeNode(genre, "Genre",
                featGenreFilter(genre),
                featGenreGetter(genre), 
                featSorter('popularity', true));
        gnodes.push(node); 
    });
}

function featGenreFilter(genre) {
    return function(track) {
        return track.feats.genres.has(genre);
    };
}

function featGenreGetter(genre) {
    return function(track) {
        var glist = Array.from(track.feats.genres);
        return glist.join(', ');
    };
}

function featGenreSorter(genre) {
    return function(tracks) {
        tracks.sort(function(a,b) {
            if (a.feats.genres.size > b.feats.genres.size) {
                return 1;
            } else if (a.feats.genres.size < b.feats.genres.size) {
                return -1;
            } else {
                return b.feats.popularity - a.feats.popularity;
            }
        });
        return tracks;
    };
}

function featSorter(param, reverse) {
    return function(tracks) {
        tracks.sort(function(a,b) {
            if (a.feats[param] > b.feats[param]) {
                return 1;
            } else if (a.feats[param] < b.feats[param]) {
                return -1;
            } else {
                return 0;
            }
        });
        if (reverse) {
            tracks.reverse();
        }
        return tracks;
    };
}

function featGetter(param) {
    return function(track) {
        return track.feats[param];
    };
}

function featGetterInt(param) {
    return function(track) {
        return Math.round(track.feats[param]);
    };
}

function featGetterPercent(param) {
    return function(track) {
        return Math.round(100 * track.feats[param]);
    };
}

function featGetterBool(param, true_val, false_val) {
    return function(track) {
        return track.feats[param] ? true_val : false_val;
    };
}

function featBoolFilter(param, state) {
    return function(track) {
        return 'feats' in track &&
                track.feats[param] == state;
    };
}
function featMusicFilter(param, low, high) {
    return function(track) {
        return 'feats' in track &&
                track.feats.speechiness < .8 && 
                track.feats[param] >= low &&  
                track.feats[param] <= high;
    };
}

function featMissingFilter(param) {
    return function(track) {
        return (! ('energy' in track.feats));
    };
}

function featFilter(param, low, high) {
    return function(track) {
        return 'feats' in track &&
                track.feats[param] >= low &&  
                track.feats[param] <= high;
    };
}

function applyFilter(tracks, filt) {
    var out = [];
    _.each(tracks, function(track) {
        if (filt(track)) {
            out.push(track);
        }
    });
    return out;
}


function refreshReleaseYear() {
    _.each(curTracks, function(track) {
        track.feats.year = getYearForTrack(track);
    });
}

function refreshPopularity() {
    theWorld.popularity = {
        popular:[],
        mainstream:[],
        hipster:[],
        deep_tracks:[]
    };

    _.each(curTracks, function(track) {
        var pop = track.popularity;
        if (pop > 60) {
            theWorld.popularity.popular.push(track);
        } else if (pop > 40) {
            theWorld.popularity.mainstream.push(track);
        } else if (pop > 10) {
            theWorld.popularity.hipster.push(track);
        } else {
            theWorld.popularity.deep_tracks.push(track);
        }
    });
    refreshNewMusic();
}



function getYearForTrack(track) {
    var year = -1;
    if (track.details.album_id in curAlbums) {
        var album = curAlbums[track.details.album_id];
        if ('release_date' in album) {
            var date = album.release_date;
            if (date.length >=4) {
                var syear = date.substring(0,4);
                year = parseInt(syear);
            }
        }
    }
    return year;
}

function getGenresForTrack(track) {
    var genres = [];
    var albumId = track.details.album_id;
    if (albumId in curAlbums) {
        var album = curAlbums[albumId];
        _.each(album.genres, function(g) {
            genres.push(g);
        });
    }

    _.each(track.details.artists, function(artist) {
        if (artist.id in curArtists) {
            var detailedArtist = curArtists[artist.id];
            _.each(detailedArtist.genres, function(genre) {
                genres.push(genre);
            });
        }
    });
    if (genres.length == 0) {
        genres.push('(unclassified)');
    }
    return genres;
}

function isGoodGenre(genre) {
    var lgenre = genre.toLowerCase();
    for (var i = 0; i < skipGenrePhrases.length; i++) {
        var phrase = skipGenrePhrases[i];
        if (lgenre.indexOf(phrase) != -1) {
            return false;
        }
    }
    return true;
}

function error(msg) {
    info(msg);
}

function info(msg) {
    $("#info").text(msg);
}

function authorizeUser() {
    var scopes = 'user-library-read playlist-modify-public';
    var url = 'https://accounts.spotify.com/authorize?client_id=' + SPOTIFY_CLIENT_ID +
        '&response_type=token' +
        '&show_dialog=false' +
        '&scope=' + encodeURIComponent(scopes) +
        '&redirect_uri=' + encodeURIComponent(SPOTIFY_REDIRECT_URI);
    document.location = url;
}

function parseArgs() {
    var hash = location.hash.replace(/#/g, '');
    var all = hash.split('&');
    var args = {};
    _.each(all, function(keyvalue) {
        var kv = keyvalue.split('=');
        var key = kv[0];
        var val = kv[1];
        args[key] = val;
    });
    return args;
}

function callSpotify(type, url, json, callback) {
    $.ajax(url, {
        type: type,
        data: JSON.stringify(json),
        dataType: 'json',
        headers: {
            'Authorization': 'Bearer ' + accessToken,
            'Content-Type': 'application/json'
        },
        success: function(r) {
            callback(true, r);
        },
        error: function(r) {
            // 2XX status codes are good, but some have no
            // response data which triggers the error handler
            // convert it to goodness.
            if (r.status >= 200 && r.status < 300) {
                callback(true, r);
            } else {
                callback(false, r);
            }
        }
    });
}

function getSpotifyWithRetries(url, data, callback) {
    var curRetry = 0;
    var maxRetries = 10;

    function go() {
        $.ajax(url, {
            dataType: 'json',
            data: data,
            headers: {
                'Authorization': 'Bearer ' + accessToken
            },
            success: function(r) {
                curRetry = 0;
                callback(r);
            },
            error: function(r) {
                // if the status is a 401, we have been
                // logged out, so lets just go back to the start
                // so the user can reauth

                // for larger collections, we will often
                // get 502 errors. Trying again usually
                // works ok

                // if we get a 429, we have hit the rate limit
                // so we need to slow down

                // 2XX status codes are good, but some have no
                // response data which triggers the error handler
                // convert it to goodness.
                if (r.status >= 200 && r.status < 300) {
                    callback(r);
                } else if (r.status == 401) {
                    window.location = 'index.html';
                } else if (r.status >= 500 && r.status < 600) {
                    if (curRetry++ < maxRetries) {
                        console.log('500 retry', curRetry, r.status);
                        setTimeout(go, 500);
                    } else {
                        console.log('500 error', r);
                        callback(null);
                    }
                } else if (r.status == 429) {
                    console.log("429 status", r);
                    var retry = 2000;
                    var retryAfter = r.getResponseHeader("Retry-After");
                    console.log("retryAfter is", retryAfter);

                    if (retryAfter) {
                        retry = parseInt(retryAfter, 10) * 1000;
                    }
                    if (retry < 1000) {
                        retry = 1000;
                    }
                    console.log("retry", retry);
                    if (curRetry++ < maxRetries) {
                        console.log('429 retry', curRetry);
                        setTimeout(go, retry + curRetry * retry);
                    } else {
                        console.log('429 error', r);
                        callback(null);
                    }
                } else {
                    console.log('error', r);
                    callback(null);
                }
            }
        });
    }
    go();
}

function getSpotify(url, data, callback) {
    return getSpotifyWithRetries(url, data, callback);
}


function fetchCurrentUserProfile(callback) {
    var url = 'https://api.spotify.com/v1/me';
    getSpotify(url, null, callback);
}


function playTrack(track) {
    if (track != nowPlaying) {
        audio.attr('src', track.details.preview_url);
        audio.get(0).play();
        nowPlaying = track;
    } else {
        stopTrack();
    }
}

function stopTrack() {
    audio.get(0).pause();
    nowPlaying = null;
}

function autoRefresh() {
    var minRefreshTime = 2000;
    function refresher() {
        var start = now();
        refreshTheWorld();
        var delta = now() - start;
        var nextRefresh = Math.max(delta * 10, minRefreshTime);
        console.log('next refresh in', nextRefresh);
        setTimeout(refresher, nextRefresh);
    }
    setTimeout(refresher, minRefreshTime);
}

function collectAudioAttributes(tracks, isLast) {
    var trackIds = [];
    _.each(tracks, function(track) {
        trackIds.push(track.id);
    });

    getSpotify("https://api.spotify.com/v1/audio-features", 
        { ids: trackIds.join(',')}, function(results) {
        _.each(results.audio_features, function(audio_feature) {
            if (audio_feature) {
                var track = curTracks[audio_feature.id];
                //track.audio_feature = audio_feature;
                _.each(audio_feature, function(val, name) {
                    track.feats[name] = val;
                });
                track.feats.sadness=  (1 - audio_feature.energy) * (1 - audio_feature.valence);
                track.feats.happiness = audio_feature.energy * audio_feature.valence;
                track.feats.anger = audio_feature.energy * (1 - audio_feature.valence);
            }
        });
        needsRefresh = true;
    });
}

function collectArtistAttributes(tracks, isLast) {
    var aids = [];
    var maxArtistsPerCall = 50;

    function getNextArtists() {
        var nextAids = getNextBatch(aids, maxArtistsPerCall);
        if (nextAids.length > 0) {
            getSpotify("https://api.spotify.com/v1/artists", 
                { ids: nextAids.join(',')}, function(results) {
                _.each(results.artists, function(artist) {
                    curArtists[artist.id] = {
                        genres:artist.genres
                    }
                });
                getNextArtists();
            });
        } else {
            needsRefresh = true;
        }
    }

    var aidsSet = new Set();
    _.each(tracks, function(track) {
        _.each(track.details.artists, function(artist) {
            if (! (artist.id in curArtists)) {
                aidsSet.add(artist.id);
            }
        });
    });
    aids = Array.from(aidsSet);
    getNextArtists();
}


function collectAlbumAttributes(tracks, isLast) {
    var maxAlbumsPerCall = 20;
    var aids = [];

    function getNextAlbums() {
        var nextAids = getNextBatch(aids, maxAlbumsPerCall);
        if (nextAids.length > 0) {
            getSpotify("https://api.spotify.com/v1/albums", 
                { ids: nextAids.join(',')}, function(results) {
                _.each(results.albums, function(album) {
                    curAlbums[album.id] = {
                        release_date:album.release_date,
                        genres:album.genres,
                    };
                });
                getNextAlbums();
            });
        } else {
            needsRefresh = true;
        }
    }

    var aidSet = new Set();
    _.each(tracks, function(track) {
        if (! (track.details.album_id in curAlbums)) {
            aidSet.add(track.details.album_id);
        }
    });
    aids = Array.from(aidSet);
    getNextAlbums();
}

function getNextBatch(list, nitems) {
    var out = [];
    while (list.length > 0 && out.length  < nitems) {
        out.push(list.shift());
    }
    return out;
}


var trackTextQueue = [];

function showTracks(prefix, tracks) {
    var tt = $("#tiny-track");
    trackTextQueue = tracks.slice();

    function scheduleUpdate() {
        if (trackTextQueue.length > 0) {
            var track = trackTextQueue.shift();
            var text = prefix + " - " + track.details.artists[0].name 
                + " - " +  track.details.name;
            tt.text(text);
            if (trackTextQueue.length > 0) {
                setTimeout(scheduleUpdate, 10);
            }
        } else {
            tt.text("");
        }
    }
    setTimeout(scheduleUpdate, 20);
}

function getTracksFromAPI(uri, offset, callback) {
    var params = {
        limit:50,
        market:'from_token',
        offset:offset,
    }
    getSpotify(uri, params, 
        function(results) {
            if (results == null) {
                error("Trouble getting your tracks");
                callback(null);
            } else {
                var now = moment();
                var tracks = [];
                _.each(results.items, function(item) {
                    if (!item.is_local && item.track && ('id' in item.track)) {
                        item.track.added_at = item.added_at;
                        item.track.date_added = moment(item.added_at);
                        item.track.age = moment.duration(now.diff(item.track.date_added)).asDays();
                        var track = {
                            id:item.track.id,
                            feats: {
                                date_added:moment(item.added_at),
                                age:moment.duration(now.diff(item.track.date_added)).asDays(),
                                explicit:item.track.explicit,
                                duration_ms:item.track.duration_ms,
                                popularity:item.track.popularity,
                                count:1,
                            },
                            // details:item.track
                            details: {
                                name:item.track.name,
                                album_id:item.track.album.id,
                                uri:item.track.uri,
                                preview_url:item.track.preview_url,
                                artists:tinyArtists(item.track.artists),
                            }
                        }
                        if (track.id in curTracks) {
                            curTracks[track.id].feats.count += 1;
                        } else {
                            tracks.push(track);
                            curTracks[track.id] = track;
                        }
                    }
                });
                showTracks(curPlaylistName, tracks);
                refreshHeader();

                var isLast = results.offset + results.items.length >= results.total;
                totalTracks = results.total;

                collectAudioAttributes(tracks, isLast);
                collectArtistAttributes(tracks, isLast);
                collectAlbumAttributes(tracks, isLast);

                if (!isLast) {
                    getTracksFromAPI(uri, results.offset + results.items.length, callback);
                } else {
                    needsRefresh = true;
                    if (callback !== undefined) {
                        callback();
                    }
                }
            }
        }
    );
}

function tinyArtists(artists) {
    var tartists = [];
    _.each(artists, function(artist) {
        var tartist = {
            id:artist.id,
            name:artist.name,
        }
        tartists.push(tartist);
    });
    return tartists;
}

function getSavedTracks() {
    return getTracksFromAPI("https://api.spotify.com/v1/me/tracks", 0);
}

var outstandingPlaylists = [];
var fetchingInProgress = false;

function getAllMusic() {
    // get all the tracks from all the 'own'
    // playlists of the user, up to a maximum amount
    function getMyPlaylists(offset) {
        var params = { limit:50, offset:offset };
        getSpotify("https://api.spotify.com/v1/me/playlists", params, function(results) {
            if (results) {
                var count = results.offset + results.items.length;
                if (count < results.total) {
                    _.each(results.items, function(playlist) {
                        if (isGoodPlaylist(playlist)) {
                            totalPlaylists += 1;
                            outstandingPlaylists.push(playlist);
                            loadPlaylists();
                            subtitle("Loading playlist: " 
                                + playlist.name + " (" + playlist.tracks.total +
                                " tracks)");
                        }
                    });
                    getMyPlaylists(count);
                }
            } else {
                error("Can't get your playlists");
            }
        });
    }
    getMyPlaylists(0);
}

var fetchingInProgress = false;

function loadPlaylists() {
    function fetchNextPlaylist() {
        if (outstandingPlaylists.length > 0) {
            fetchingInProgress = true;
            var playlist = outstandingPlaylists.shift();
            processedPlaylists += 1;
            // console.log("loading " + playlist.name + " tracks " + playlist.tracks.total);
            curPlaylistName = playlist.name;
            getPlaylistTracks(playlist.uri, function() {
                fetchNextPlaylist();
            });
        } else {
            fetchingInProgress = false;
        }
    }
    if (!fetchingInProgress) {
        fetchNextPlaylist();
    }
}

function isGoodPlaylist(playlist) {
    if (playlist.owner.id == curUserID) {
        if (playlist.tracks.total > 0) {
            return true;
        }
    }
    return false;
}

function getPlaylistTitleAndTracks(uri) {
    if (isValidPlaylistUri(uri)) {
        var fields = uri.split(':');
        var userID = fields[2];
        var playlistID = fields[4];
        var url = "https://api.spotify.com/v1/users/" 
            + userID + "/playlists/" + playlistID;
        var params = { fields:"name" };
        getSpotify(url, params, function(results) {
            if (results) {
                curName = results.name + ": " ;
                getPlaylistTracks(uri);
            } else {
                error("Trouble reading playlist");
            }
        });
    }
}

function getPlaylistTracks(uri, callback) {
    if (isValidPlaylistUri(uri)) {
        var fields = uri.split(':');
        var userID = fields[2];
        var playlistID = fields[4];
        var url = "https://api.spotify.com/v1/users/" 
            + userID + "/playlists/" + playlistID + "/tracks";
        return getTracksFromAPI(url, 0, callback);
    } else {
        error("bad playlist URI");
    }
}

function isLocalHost() {
    return window.location.host.indexOf('localhost') >= 0;
}

function isValidPlaylistUri(uri) {
    var fields = uri.split(':');
    if (fields.length != 5) {
        return false;
    }
    if (fields[0] != 'spotify' || fields[3] != 'playlist') {
        return false;
    }
    return true;
}

function saveInfo(params) {
    localStorage.setItem("info", JSON.stringify(params));
}

function getInfo(params) {
    var item = localStorage.getItem("info");
    return JSON.parse(item);
}

function goCollection() {
    $('.err-txt').text("");
    var params = {
        "type": "collection",
    }
    saveInfo(params);
    authorizeUser();
}

function goAll() {
    $('.err-txt').text("");
    var params = {
        "type": "all",
    }
    saveInfo(params);
    authorizeUser();
}

function normalizeUri(uri) {
    uri = uri.replace("https://open.spotify.com", 'spotify');
    uri = uri.replace("https://play.spotify.com", 'spotify');
    uri = uri.replace(/\//g, ':');
    return uri;
}

function goPlaylist() {
    $('.err-txt').text("");
    var uri = normalizeUri($("#uri-text").val());
    if (isValidPlaylistUri(uri)) {
        var params = {
            "type": "playlist",
            "uri": uri
        }
        saveInfo(params);
        authorizeUser();
    } else {
        $('.err-txt').text("That's not a playlist URI");
    }
}

function setProgress(percent) {
  progressBar.css('width', percent+'%').attr('aria-valuenow', percent);    

}

$(document).ready(

    function() {

        if (isLocalHost()) {
            SPOTIFY_REDIRECT_URI = LOCAL_SPOTIFY_REDIRECT_URI;
        } 
        var args = parseArgs();
        window.location.hash = "";
        $(".work").hide();
        if ('error' in args) {
            error("Sorry, I can't read your music collection from Spotify without authorization");
            $("#go").show();
            $("#go").on('click', function() {
                goCollection();
            });
        } else if ('access_token' in args) {
            $(".work").show();
            $("#intro").hide();
            accessToken = args['access_token'];
            $("#save-button").on("click", function() {
                savePlaylist();
            });
            fetchCurrentUserProfile(function(user) {
                if (user) {
                    curUserID = user.id;
                    $("#who").text(user.id);
                    var info = getInfo();
                    curType = info.type;
                    if (info.type == "collection") {
                        getSavedTracks();
                    } else if (info.type == "all") {
                        getAllMusic();
                    } else if (info.type == "playlist") {
                        getPlaylistTitleAndTracks(info.uri);
                    }
                    autoRefresh();
                } else {
                    error("Trouble getting the user profile");
                }
            });
        } else {
            $("#go").show();
            $("#go").on('click', function() {
                goCollection();
            });

            $("#go-all").on('click', function() {
                goAll();
            });

            $("#uri-go").on('click', goPlaylist);
            $("#uri-text").keyup(
                 function(event) {
                    if(event.keyCode == 13) {
                        goPlaylist();
                    }
                });
        }
    }
);

</script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3675615-27']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type =
'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
